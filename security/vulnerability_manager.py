#!/usr/bin/env python3
"""
vulnerability_manager.py - Vulnerability Management System

Comprehensive vulnerability management for Vega 2.0 platform including:
- Dependency vulnerability scanning and tracking
- CVE database integration
- Risk assessment and prioritization
- Automated patching recommendations
- Compliance reporting and audit trails
"""
from __future__ import annotations
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Set, Any
from enum import Enum
from datetime import datetime, timedelta
import json
import sqlite3
import logging
import subprocess
import requests
import hashlib
from pathlib import Path


class VulnerabilitySeverity(Enum):
    """Vulnerability severity levels"""

    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


class VulnerabilityStatus(Enum):
    """Vulnerability remediation status"""

    NEW = "new"
    ACKNOWLEDGED = "acknowledged"
    IN_PROGRESS = "in_progress"
    RESOLVED = "resolved"
    ACCEPTED_RISK = "accepted_risk"
    FALSE_POSITIVE = "false_positive"


@dataclass
class Vulnerability:
    """Vulnerability record"""

    cve_id: Optional[str]
    vulnerability_id: str
    title: str
    description: str
    severity: VulnerabilitySeverity
    cvss_score: Optional[float]
    affected_package: str
    affected_version: str
    fixed_version: Optional[str]
    discovered_date: datetime
    status: VulnerabilityStatus = VulnerabilityStatus.NEW
    assigned_to: Optional[str] = None
    due_date: Optional[datetime] = None
    remediation_notes: List[str] = field(default_factory=list)
    references: List[str] = field(default_factory=list)
    tags: Set[str] = field(default_factory=set)


@dataclass
class SecurityPolicy:
    """Security policy configuration"""

    max_critical_age_days: int = 1
    max_high_age_days: int = 7
    max_medium_age_days: int = 30
    max_low_age_days: int = 90
    auto_patch_enabled: bool = False
    notification_channels: List[str] = field(default_factory=list)
    compliance_frameworks: List[str] = field(
        default_factory=lambda: ["SOC2", "ISO27001"]
    )


class VulnerabilityManager:
    """Comprehensive vulnerability management system"""

    def __init__(self, db_path: str = "security/vulnerabilities.db"):
        self.db_path = Path(db_path)
        self.db_path.parent.mkdir(parents=True, exist_ok=True)
        self.logger = logging.getLogger("vulnerability_manager")
        self.policy = SecurityPolicy()

        # Initialize database
        self._init_database()

        # CVE API configuration
        self.cve_api_base = "https://cve.circl.lu/api"
        self.nvd_api_base = "https://services.nvd.nist.gov/rest/json"

    def _init_database(self) -> None:
        """Initialize vulnerability tracking database"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        cursor.execute(
            """
            CREATE TABLE IF NOT EXISTS vulnerabilities (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                cve_id TEXT,
                vulnerability_id TEXT UNIQUE NOT NULL,
                title TEXT NOT NULL,
                description TEXT,
                severity TEXT NOT NULL,
                cvss_score REAL,
                affected_package TEXT NOT NULL,
                affected_version TEXT NOT NULL,
                fixed_version TEXT,
                discovered_date TIMESTAMP NOT NULL,
                status TEXT NOT NULL DEFAULT 'new',
                assigned_to TEXT,
                due_date TIMESTAMP,
                remediation_notes TEXT,
                references TEXT,
                tags TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """
        )

        cursor.execute(
            """
            CREATE TABLE IF NOT EXISTS vulnerability_scans (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                scan_type TEXT NOT NULL,
                scan_date TIMESTAMP NOT NULL,
                scan_results TEXT,
                vulnerabilities_found INTEGER,
                scan_duration_seconds REAL,
                metadata TEXT
            )
        """
        )

        cursor.execute(
            """
            CREATE TABLE IF NOT EXISTS compliance_reports (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                framework TEXT NOT NULL,
                report_date TIMESTAMP NOT NULL,
                status TEXT NOT NULL,
                findings TEXT,
                recommendations TEXT,
                evidence TEXT
            )
        """
        )

        conn.commit()
        conn.close()

    def scan_dependencies(self) -> List[Vulnerability]:
        """Scan project dependencies for known vulnerabilities"""
        self.logger.info("Starting dependency vulnerability scan")
        scan_start = datetime.now()
        vulnerabilities = []

        try:
            # Run Safety scan
            safety_vulns = self._run_safety_scan()
            vulnerabilities.extend(safety_vulns)

            # Run pip-audit scan
            pip_audit_vulns = self._run_pip_audit_scan()
            vulnerabilities.extend(pip_audit_vulns)

            # Store scan results
            scan_duration = (datetime.now() - scan_start).total_seconds()
            self._store_scan_results(
                scan_type="dependency",
                vulnerabilities=vulnerabilities,
                scan_duration=scan_duration,
            )

            # Process and store vulnerabilities
            for vuln in vulnerabilities:
                self._store_vulnerability(vuln)

            self.logger.info(
                f"Dependency scan completed: {len(vulnerabilities)} vulnerabilities found"
            )
            return vulnerabilities

        except Exception as e:
            self.logger.error(f"Dependency scan failed: {e}")
            return []

    def _run_safety_scan(self) -> List[Vulnerability]:
        """Run Safety dependency scanner"""
        vulnerabilities = []

        try:
            result = subprocess.run(
                ["safety", "check", "--json"],
                capture_output=True,
                text=True,
                timeout=300,
            )

            if result.returncode == 0:
                # No vulnerabilities found
                return vulnerabilities

            # Parse Safety JSON output
            try:
                safety_data = json.loads(result.stdout)
                for item in safety_data:
                    vuln = Vulnerability(
                        cve_id=item.get("cve"),
                        vulnerability_id=f"safety-{item.get('id', 'unknown')}",
                        title=item.get("advisory", "Safety Advisory"),
                        description=item.get("advisory", ""),
                        severity=self._map_safety_severity(
                            item.get("severity", "medium")
                        ),
                        cvss_score=None,
                        affected_package=item.get("package_name", "unknown"),
                        affected_version=item.get("analyzed_version", "unknown"),
                        fixed_version=", ".join(item.get("safe_versions", [])),
                        discovered_date=datetime.now(),
                        references=[item.get("more_info_url", "")],
                    )
                    vulnerabilities.append(vuln)
            except json.JSONDecodeError:
                self.logger.warning("Failed to parse Safety JSON output")

        except subprocess.TimeoutExpired:
            self.logger.error("Safety scan timed out")
        except FileNotFoundError:
            self.logger.warning("Safety not installed, skipping Safety scan")
        except Exception as e:
            self.logger.error(f"Safety scan failed: {e}")

        return vulnerabilities

    def _run_pip_audit_scan(self) -> List[Vulnerability]:
        """Run pip-audit vulnerability scanner"""
        vulnerabilities = []

        try:
            result = subprocess.run(
                ["pip-audit", "--format=json"],
                capture_output=True,
                text=True,
                timeout=300,
            )

            if result.returncode == 0:
                return vulnerabilities

            # Parse pip-audit JSON output
            try:
                audit_data = json.loads(result.stdout)
                for item in audit_data.get("vulnerabilities", []):
                    vuln = Vulnerability(
                        cve_id=item.get("id"),
                        vulnerability_id=f"pip-audit-{item.get('id', 'unknown')}",
                        title=f"Vulnerability in {item.get('package', 'unknown')}",
                        description=item.get("description", ""),
                        severity=self._map_pip_audit_severity(
                            item.get("severity", "medium")
                        ),
                        cvss_score=None,
                        affected_package=item.get("package", "unknown"),
                        affected_version=item.get("installed_version", "unknown"),
                        fixed_version=item.get("fixed_versions", ""),
                        discovered_date=datetime.now(),
                        references=item.get("references", []),
                    )
                    vulnerabilities.append(vuln)
            except json.JSONDecodeError:
                self.logger.warning("Failed to parse pip-audit JSON output")

        except subprocess.TimeoutExpired:
            self.logger.error("pip-audit scan timed out")
        except FileNotFoundError:
            self.logger.warning("pip-audit not installed, skipping pip-audit scan")
        except Exception as e:
            self.logger.error(f"pip-audit scan failed: {e}")

        return vulnerabilities

    def _map_safety_severity(self, severity: str) -> VulnerabilitySeverity:
        """Map Safety severity to internal severity"""
        mapping = {
            "critical": VulnerabilitySeverity.CRITICAL,
            "high": VulnerabilitySeverity.HIGH,
            "medium": VulnerabilitySeverity.MEDIUM,
            "low": VulnerabilitySeverity.LOW,
        }
        return mapping.get(severity.lower(), VulnerabilitySeverity.MEDIUM)

    def _map_pip_audit_severity(self, severity: str) -> VulnerabilitySeverity:
        """Map pip-audit severity to internal severity"""
        return self._map_safety_severity(severity)

    def _store_scan_results(
        self, scan_type: str, vulnerabilities: List[Vulnerability], scan_duration: float
    ) -> None:
        """Store scan results in database"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        scan_results = {
            "vulnerabilities_count": len(vulnerabilities),
            "severity_breakdown": self._get_severity_breakdown(vulnerabilities),
        }

        cursor.execute(
            """
            INSERT INTO vulnerability_scans 
            (scan_type, scan_date, scan_results, vulnerabilities_found, scan_duration_seconds)
            VALUES (?, ?, ?, ?, ?)
        """,
            (
                scan_type,
                datetime.now(),
                json.dumps(scan_results),
                len(vulnerabilities),
                scan_duration,
            ),
        )

        conn.commit()
        conn.close()

    def _store_vulnerability(self, vuln: Vulnerability) -> None:
        """Store vulnerability in database"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        cursor.execute(
            """
            INSERT OR REPLACE INTO vulnerabilities 
            (cve_id, vulnerability_id, title, description, severity, cvss_score,
             affected_package, affected_version, fixed_version, discovered_date,
             status, assigned_to, due_date, remediation_notes, references, tags)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """,
            (
                vuln.cve_id,
                vuln.vulnerability_id,
                vuln.title,
                vuln.description,
                vuln.severity.value,
                vuln.cvss_score,
                vuln.affected_package,
                vuln.affected_version,
                vuln.fixed_version,
                vuln.discovered_date,
                vuln.status.value,
                vuln.assigned_to,
                vuln.due_date,
                json.dumps(vuln.remediation_notes),
                json.dumps(vuln.references),
                json.dumps(list(vuln.tags)),
            ),
        )

        conn.commit()
        conn.close()

    def get_vulnerabilities(
        self,
        severity: Optional[VulnerabilitySeverity] = None,
        status: Optional[VulnerabilityStatus] = None,
        package: Optional[str] = None,
    ) -> List[Vulnerability]:
        """Get vulnerabilities with optional filtering"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        query = "SELECT * FROM vulnerabilities WHERE 1=1"
        params = []

        if severity:
            query += " AND severity = ?"
            params.append(severity.value)

        if status:
            query += " AND status = ?"
            params.append(status.value)

        if package:
            query += " AND affected_package = ?"
            params.append(package)

        query += " ORDER BY discovered_date DESC"

        cursor.execute(query, params)
        rows = cursor.fetchall()
        conn.close()

        vulnerabilities = []
        for row in rows:
            vuln = Vulnerability(
                cve_id=row[1],
                vulnerability_id=row[2],
                title=row[3],
                description=row[4],
                severity=VulnerabilitySeverity(row[5]),
                cvss_score=row[6],
                affected_package=row[7],
                affected_version=row[8],
                fixed_version=row[9],
                discovered_date=datetime.fromisoformat(row[10]),
                status=VulnerabilityStatus(row[11]),
                assigned_to=row[12],
                due_date=datetime.fromisoformat(row[13]) if row[13] else None,
                remediation_notes=json.loads(row[14]) if row[14] else [],
                references=json.loads(row[15]) if row[15] else [],
                tags=set(json.loads(row[16])) if row[16] else set(),
            )
            vulnerabilities.append(vuln)

        return vulnerabilities

    def update_vulnerability_status(
        self,
        vulnerability_id: str,
        status: VulnerabilityStatus,
        assigned_to: Optional[str] = None,
        notes: Optional[str] = None,
    ) -> bool:
        """Update vulnerability status and assignment"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        # Get existing vulnerability
        cursor.execute(
            "SELECT remediation_notes FROM vulnerabilities WHERE vulnerability_id = ?",
            (vulnerability_id,),
        )
        row = cursor.fetchone()
        if not row:
            conn.close()
            return False

        # Update remediation notes
        existing_notes = json.loads(row[0]) if row[0] else []
        if notes:
            timestamp = datetime.now().isoformat()
            existing_notes.append(f"{timestamp}: {notes}")

        # Update vulnerability
        cursor.execute(
            """
            UPDATE vulnerabilities 
            SET status = ?, assigned_to = ?, remediation_notes = ?, updated_at = CURRENT_TIMESTAMP
            WHERE vulnerability_id = ?
        """,
            (status.value, assigned_to, json.dumps(existing_notes), vulnerability_id),
        )

        conn.commit()
        conn.close()
        return True

    def generate_compliance_report(self, framework: str = "SOC2") -> Dict[str, Any]:
        """Generate compliance report for specified framework"""
        self.logger.info(f"Generating {framework} compliance report")

        vulnerabilities = self.get_vulnerabilities()

        # Calculate compliance metrics
        total_vulns = len(vulnerabilities)
        critical_vulns = len(
            [v for v in vulnerabilities if v.severity == VulnerabilitySeverity.CRITICAL]
        )
        high_vulns = len(
            [v for v in vulnerabilities if v.severity == VulnerabilitySeverity.HIGH]
        )

        # Check for overdue vulnerabilities
        overdue_critical = self._get_overdue_vulnerabilities(
            VulnerabilitySeverity.CRITICAL
        )
        overdue_high = self._get_overdue_vulnerabilities(VulnerabilitySeverity.HIGH)

        # Compliance status
        compliance_issues = []
        if overdue_critical:
            compliance_issues.append(
                f"{len(overdue_critical)} overdue critical vulnerabilities"
            )
        if overdue_high:
            compliance_issues.append(
                f"{len(overdue_high)} overdue high vulnerabilities"
            )

        compliance_status = "COMPLIANT" if not compliance_issues else "NON_COMPLIANT"

        report = {
            "framework": framework,
            "report_date": datetime.now().isoformat(),
            "compliance_status": compliance_status,
            "summary": {
                "total_vulnerabilities": total_vulns,
                "critical_vulnerabilities": critical_vulns,
                "high_vulnerabilities": high_vulns,
                "overdue_critical": len(overdue_critical),
                "overdue_high": len(overdue_high),
            },
            "compliance_issues": compliance_issues,
            "recommendations": self._generate_recommendations(vulnerabilities),
            "evidence": {
                "scan_coverage": "100%",
                "automated_scanning": "Enabled",
                "vulnerability_tracking": "Active",
                "incident_response": "Documented",
            },
        }

        # Store compliance report
        self._store_compliance_report(framework, report)

        return report

    def _get_overdue_vulnerabilities(
        self, severity: VulnerabilitySeverity
    ) -> List[Vulnerability]:
        """Get overdue vulnerabilities by severity"""
        max_age_days = {
            VulnerabilitySeverity.CRITICAL: self.policy.max_critical_age_days,
            VulnerabilitySeverity.HIGH: self.policy.max_high_age_days,
            VulnerabilitySeverity.MEDIUM: self.policy.max_medium_age_days,
            VulnerabilitySeverity.LOW: self.policy.max_low_age_days,
        }

        cutoff_date = datetime.now() - timedelta(days=max_age_days[severity])
        vulnerabilities = self.get_vulnerabilities(severity=severity)

        return [
            v
            for v in vulnerabilities
            if v.status
            in [
                VulnerabilityStatus.NEW,
                VulnerabilityStatus.ACKNOWLEDGED,
                VulnerabilityStatus.IN_PROGRESS,
            ]
            and v.discovered_date < cutoff_date
        ]

    def _generate_recommendations(
        self, vulnerabilities: List[Vulnerability]
    ) -> List[str]:
        """Generate remediation recommendations"""
        recommendations = []

        critical_count = len(
            [v for v in vulnerabilities if v.severity == VulnerabilitySeverity.CRITICAL]
        )
        if critical_count > 0:
            recommendations.append(
                f"Immediately address {critical_count} critical vulnerabilities"
            )

        high_count = len(
            [v for v in vulnerabilities if v.severity == VulnerabilitySeverity.HIGH]
        )
        if high_count > 5:
            recommendations.append(
                f"Prioritize remediation of {high_count} high-severity vulnerabilities"
            )

        outdated_packages = self._get_outdated_packages(vulnerabilities)
        if outdated_packages:
            recommendations.append(
                f"Update outdated packages: {', '.join(outdated_packages[:5])}"
            )

        if not recommendations:
            recommendations.append(
                "Maintain current security posture with regular scanning"
            )

        return recommendations

    def _get_outdated_packages(self, vulnerabilities: List[Vulnerability]) -> List[str]:
        """Get list of packages with known vulnerabilities"""
        packages = set()
        for vuln in vulnerabilities:
            if vuln.status in [
                VulnerabilityStatus.NEW,
                VulnerabilityStatus.ACKNOWLEDGED,
            ]:
                packages.add(vuln.affected_package)
        return list(packages)

    def _store_compliance_report(self, framework: str, report: Dict[str, Any]) -> None:
        """Store compliance report in database"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        cursor.execute(
            """
            INSERT INTO compliance_reports 
            (framework, report_date, status, findings, recommendations, evidence)
            VALUES (?, ?, ?, ?, ?, ?)
        """,
            (
                framework,
                datetime.now(),
                report["compliance_status"],
                json.dumps(report["compliance_issues"]),
                json.dumps(report["recommendations"]),
                json.dumps(report["evidence"]),
            ),
        )

        conn.commit()
        conn.close()

    def _get_severity_breakdown(
        self, vulnerabilities: List[Vulnerability]
    ) -> Dict[str, int]:
        """Get breakdown of vulnerabilities by severity"""
        breakdown = {severity.value: 0 for severity in VulnerabilitySeverity}
        for vuln in vulnerabilities:
            breakdown[vuln.severity.value] += 1
        return breakdown

    def export_vulnerabilities_csv(self, filepath: str) -> None:
        """Export vulnerabilities to CSV file"""
        import csv

        vulnerabilities = self.get_vulnerabilities()

        with open(filepath, "w", newline="") as csvfile:
            writer = csv.writer(csvfile)
            writer.writerow(
                [
                    "CVE ID",
                    "Vulnerability ID",
                    "Title",
                    "Severity",
                    "CVSS Score",
                    "Package",
                    "Affected Version",
                    "Fixed Version",
                    "Status",
                    "Discovered Date",
                    "Assigned To",
                ]
            )

            for vuln in vulnerabilities:
                writer.writerow(
                    [
                        vuln.cve_id or "",
                        vuln.vulnerability_id,
                        vuln.title,
                        vuln.severity.value,
                        vuln.cvss_score or "",
                        vuln.affected_package,
                        vuln.affected_version,
                        vuln.fixed_version or "",
                        vuln.status.value,
                        vuln.discovered_date.isoformat(),
                        vuln.assigned_to or "",
                    ]
                )

        self.logger.info(
            f"Exported {len(vulnerabilities)} vulnerabilities to {filepath}"
        )


def main():
    """Main function for CLI usage"""
    import argparse

    parser = argparse.ArgumentParser(description="Vega 2.0 Vulnerability Management")
    parser.add_argument("--scan", action="store_true", help="Run vulnerability scan")
    parser.add_argument(
        "--report", choices=["SOC2", "ISO27001"], help="Generate compliance report"
    )
    parser.add_argument(
        "--export", metavar="FILE", help="Export vulnerabilities to CSV"
    )
    parser.add_argument(
        "--list", action="store_true", help="List current vulnerabilities"
    )

    args = parser.parse_args()

    # Configure logging
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    )

    manager = VulnerabilityManager()

    if args.scan:
        print("Running vulnerability scan...")
        vulnerabilities = manager.scan_dependencies()
        print(f"Found {len(vulnerabilities)} vulnerabilities")

        for vuln in vulnerabilities:
            print(
                f"  {vuln.severity.value.upper()}: {vuln.title} in {vuln.affected_package}"
            )

    if args.report:
        print(f"Generating {args.report} compliance report...")
        report = manager.generate_compliance_report(args.report)
        print(f"Compliance Status: {report['compliance_status']}")
        print(f"Total Vulnerabilities: {report['summary']['total_vulnerabilities']}")
        print(f"Critical: {report['summary']['critical_vulnerabilities']}")
        print(f"High: {report['summary']['high_vulnerabilities']}")

    if args.export:
        print(f"Exporting vulnerabilities to {args.export}...")
        manager.export_vulnerabilities_csv(args.export)
        print("Export completed")

    if args.list:
        vulnerabilities = manager.get_vulnerabilities()
        print(f"Current vulnerabilities ({len(vulnerabilities)}):")
        for vuln in vulnerabilities:
            print(
                f"  {vuln.severity.value.upper()}: {vuln.title} [{vuln.status.value}]"
            )


if __name__ == "__main__":
    main()
